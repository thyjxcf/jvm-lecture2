package com.shengsiyuan.jvm.memory;

/**
 * 虚拟机栈：Stack Frame 栈帧 存储操作数栈里面的数据，存储局部变量表
 * 每个方法执行的时候都会形成栈帧这个数据结构
 *
 * 程序计数器：（program counter)：记录执行那行字节码
 * 本地方法栈：主要用于执行本地方法 。native方法，不是由java实现，具体实现是由c或c++实现
 * （对于oracle的java虚拟机hotspot来说是将虚拟机栈和本地方法栈合二为一了）
 *
 * 堆（heap 占据最大内存):（虚拟机创建的时候，内存就会申请下来，用来存放对象实例）JVM管理的最大一部分内存空间
 * 我们都是通过refrence来操作对象。
 * 对象在堆上面，而引用本身在虚拟机栈上面。位于局部变量表中的一个对象
 *
 * 对象有2种组成，一种是数据本身，一种是元数据metadata就是class对象
 * 元数据位于方法区methodArea 存储的是对象本身的类型数据
 *
 * ref指向的是一个指针pointer。
 * 里面会有2个指针 一个指向真正实例数据，一个指向方法区内的特定类型信息。
 * 第二种情况是 ，本身包含实例，还有一个指针指向方法区类型信息，
 * hotspot采用的是第二种方式
 * 堆空间是 大量对象会被回收掉 发生垃圾回收很高
 * 压缩，回收形成更大内存空间，方便对象使用
 * 方法区是极少发送垃圾回收概率的
 *
 * 方法区：（method area）：存储元信息 永久代（permanent generation) ，从jdk1.8开始彻底废弃永久代改使用元空间
 * 运行时常量池：方法区的一部分
 * 直接内存：direct memory
 * 虚拟机栈 是归属于某个线程的，是某个线程私有的
 * ban
 * 操作数栈
 * 局部变量表 就是方法局部变量一些信息（就是线程能够访问的一些局部变量信息）
 *
 * 会抛出stackOverFlow 异常
 * 如果局部变量表保存的是原生类型 就直接放在栈帧里面
 * 栈帧里面存放的是引用 ，到堆上的引用。
 * 当前执行线程执行字节码的行号位置
 * 程序计数器和虚拟机栈都是线程私有的 。
 *
 * 虚拟机栈和本地方法栈 和程序计数器，出现outOfMemory 很少的时候才会出现。
 *
 * 堆内存中的对象是被java所有线程共享的
 * 现在所有垃圾收集器都是采用分代收集算法。
 * 堆空间也会基于这一点进行相应的划分：新生代与老年代
 * Eden空间，From Servivor空间与To Servivor 空间。
 * java的堆空间在物理上既可以是连续的也可以是不连续的
 * 常量，和java的class对象信息都会放到方法区
 * 关于class元信息的卸载，就会被回收
 * 直接内存与javaNIO密切相关，JVM通过堆上DirectByteBuffer来操作直接内存
 *
 *
 */
/*
    关于java对象创建的过程：
    new关键字创建对象的3个步骤：
    1. 在堆内存中创建出对象的实例
    2. 为对象的实例变量赋初值
    3. 将对象的引用返回
    指针碰撞：（前提是堆中的空间通过一个指针进行分割，一侧是被占用的空间，另一撤未被占用的空间
    空闲列表：（前提是堆内存空间中已被使用与未被使用的内存空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录
    那些空间是可以使用的，那些空间是已被使用的，接下来找出可以容纳新创建对象且未被使用的空间，在此空间存放该对象，
    同时还要修改列表上的记录。
sfdf
 */
public class MyTest1 {
}
